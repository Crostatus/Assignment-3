import java.util.ArrayList;
import java.util.Vector;
import java.util.concurrent.locks.*;

public class patientQueueArrayList {
    final private Lock lockQueue;
    final private Condition notEmpty;
    final private ArrayList<patient> waitingRoom;

    public patientQueueArrayList(){
        lockQueue = new ReentrantLock();
        notEmpty = lockQueue.newCondition();
        waitingRoom = new ArrayList<>();
    }

    public patient getPatient(){
        lockQueue.lock();
        try {
            try {
                while(waitingRoom.isEmpty())
                    notEmpty.await();
            }
            catch(InterruptedException e){
                e.printStackTrace();
            }
            patient nextPatient = waitingRoom.get(0);
            waitingRoom.remove(0);
            return nextPatient;
        }
        finally {
            lockQueue.unlock();
        }
    }

    public void put(patient newPatient){
        int index;
        lockQueue.lock();
        try {
            //qui va calcolato l' indice corretto per il thread rimbalzato / appena creato
            index = rightIndex(newPatient);
            waitingRoom.add(index, newPatient);
            notEmpty.signal();
        }
        finally {
            lockQueue.unlock();
        }
    }

    private int rightIndex(patient newPatient){
        int i = 0;
        while(i < waitingRoom.size()){
            if(hasPriority(newPatient, waitingRoom.get(i)))
                return i;
            i++;
        }
        return i;
    }

    private boolean hasPriority(patient newPatient, patient patientInLine){
        if(newPatient.getCode() > patientInLine.getCode())
            return true;
        if((newPatient.getCode() == patientInLine.getCode()) && newPatient.getTimes() > patientInLine.getTimes() )
            return true;

        return false;
    }
}
